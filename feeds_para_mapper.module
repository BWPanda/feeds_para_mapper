<?php

   /**
    * @file
    * Allows feeds to import content to paragraph fields.
    */

  /**
   * Implements hook_feeds_processor_targets_alter().
   *
   * @param array $targets
   * @param string $entity_type
   * @param string $bundle
   *
   * @return array
   */
  function feeds_para_mapper_feeds_processor_targets_alter(&$targets, $entity_type, $bundle) {
    // Get all fields.
    $entity_fields = field_info_instances($entity_type, $bundle);
    $fields_to_include = [];
    // Search for fields of type paragraphs.
    foreach ($entity_fields as $entity_field) {
      if ($entity_field['bundle'] == $bundle && $entity_field['widget']['module'] == "paragraphs") {
        array_push($fields_to_include, $entity_field);
      }
    }
    // If there are fields of type Paragraphs founded.
    if (!empty($fields_to_include)) {
      foreach ($fields_to_include as $para_field) {
        $para_field_info = [
          'name' => $para_field['label'],
          'machine_name' => $para_field['field_name'],
          'field_id' => $para_field['field_id'],
          'bundle' => $bundle,
          'entity_type' => $entity_type,
        ];
        $temp_arr = [
          'field_info' => $para_field_info,
        ];
        $sub_fields = feeds_para_get_para_bundle_fields($temp_arr);
        foreach ($sub_fields as $sub_field) {
          $label = $sub_field['machine_name'] . ':' . $sub_field['paragraph_bundle'] . ' bundle';
          $targets[$label] = [
            'name' => t("@label", array('@label' => $sub_field['label'])),
            'field' => $sub_field,
            'paragraph' => $para_field_info,
            'description' => t('A Paragraphs field from a bundle'),
            'callback' => 'feeds_para_mapper_set_target',
            'summary_callbacks' => array('feeds_para_mapper_sum_callback'),
            'form_callbacks' => array('feeds_para_mapper_create_field_settings_form'),
          ];
        }
      }
    }
    return $targets;
  }

  /**
   * For checking the target field type then set the value accordingly.
   *
   * @param string $source
   *   The source value.
   * @param object $entity
   *   The entity that is being edited.
   * @param string $target
   *   The target field that is being mapped to.
   * @param array $value
   *   The source field value.
   * @param array $mapping
   *   Contains the settings form fields values.
   */
  function feeds_para_mapper_set_target($source, $entity, $target, array $value, array $mapping) {
    // If field is a Paragraphs field.
    if (isset($mapping['paragraph_field'])) {
      $info = field_info_field($mapping['field']);
      $tax_res = feeds_para_mapper_check_terms($mapping, $value[0], $info);
      feeds_para_mapper_get_init_para($entity, $mapping);
      $tax_list = "";
      if (isset($tax_res['terms'])) {
        foreach ($tax_res['terms'] as $retTerm) {
          $tax_list .= $retTerm['tid'] . ",";
        }
      }
      switch ($info['type']) {
        case "taxonomy_term_reference":
          // Save to a taxonomy list type field.
          feeds_para_mapper_save_tax_terms_type($info, $mapping, $tax_list, $entity);
          break;

        case "list_text":
        case "list_integer":
          // Save to a list type field.
          feeds_para_mapper_save_list_type($info, $mapping, $value[0], $entity);
          break;

        case "interval":
          // Save to interval field.
          feeds_para_mapper_save_interval_type($info, $mapping, $value[0], $entity);
          break;

        case "list_boolean":
          // Save to a boolean field.
          feeds_para_mapper_save_list_boolean_type($info, $mapping, $value[0], $entity);
          break;

        case "number_integer":
        case "number_decimal":
        case "number_float":
          // Save to numeric field.
          feeds_para_mapper_save_numeric_type($info, $mapping, $value[0], $entity);
          break;

        case "image":
        case "file":
          // Save to image field.
          feeds_para_mapper_save_file_type($info, $mapping, $value[0], $entity);
          break;

        default:
          // Save to a normal field (text, long text).
          feeds_para_mapper_save_normal($info, $mapping, $value[0], $entity);
          break;
      }
    }
  }

  /**
   * For saving a value to a normal field.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_normal($field_info, array $mapping, $value, $entity) {
    if (empty($value)) {
      return FALSE;
    }
    $values = explode($mapping['separator'], $value);
    $par_field = $mapping['paragraph_field'];
    $bundle = $mapping['paragraph_bundle'];
    $field = $mapping['field'];
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($values as $key => $val) {
      if (($added < $num_allowed || $skip_check) && !empty($val)) {
        foreach ($entity->{$par_field}['und'] as $par_key => $paragraph) {
          if ($paragraph['entity']->bundle === $bundle) {
            $added++;
            $paragraph['entity']->{$field}['und'][$key]['value'] = $val;
          }
        }
      }
    }
    return $added > 0;
  }

  /**
   * For saving a value to a numeric field.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_numeric_type(array $field_info, array $mapping, $value, $entity) {
    if (empty($value)) {
      return FALSE;
    }
    $val = NULL;
    switch ($field_info['type']) {
      case "number_integer":
        $val = (int) $value;
        break;

      case "number_decimal":
      case "number_float":
        $val = (float) $value;
        break;

      default:
        $val = NULL;
        break;
    }
    if (!$val) {
      return FALSE;
    }
    $values = explode($mapping['separator'], $val);
    $par_field = $mapping['paragraph_field'];
    $bundle = $mapping['paragraph_bundle'];
    $field = $mapping['field'];
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($values as $key => $item) {
      if (($added < $num_allowed || $skip_check) && !empty($item)) {
        foreach ($entity->{$par_field}['und'] as $paragraph) {
          if ($paragraph['entity']->bundle === $bundle) {
            $added++;
            $paragraph['entity']->{$field}['und'][$key]['value'] = $item;
          }
        }
      }
    }
    return $added > 0;
  }

  /**
   * For saving a value to an image field.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_file_type(array $field_info, array $mapping, $value, $entity) {
    if (empty($value)) {
      return FALSE;
    }
    $values = explode($mapping['separator'], $value);
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($values as $key => $item) {
      if (($added < $num_allowed || $skip_check) && !empty($item)) {
        $file = feeds_para_mapper_get_file($value);
        if ($file) {
          $par_field = $mapping['paragraph_field'];
          $bundle = $mapping['paragraph_bundle'];
          $field = $mapping['field'];
          foreach ($entity->{$par_field}['und'] as $paragraph) {
            if ($paragraph['entity']->bundle === $bundle) {
              $added++;
              $paragraph['entity']->{$field}['und'][$key] = (array) $file;
            }
          }
        }
      }
    }
    return $added > 0;
  }

  /**
   * For saving a value to a list_boolean field.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_list_boolean_type(array $field_info, array $mapping, $value, $entity) {
    if (empty($value)) {
      return FALSE;
    }
    $par_field = $mapping['paragraph_field'];
    $bundle = $mapping['paragraph_bundle'];
    $field = $mapping['field'];
    $values = explode($mapping['separator'], $value);
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($values as $key => $item) {
      if (($added < $num_allowed || $skip_check) && !empty($item)) {
        $val = ($value === "1" || $value === "true" || $value === "TRUE")? 1: 0;
        foreach ($entity->{$par_field}['und'] as $paragraph) {
          if ($paragraph['entity']->bundle === $bundle) {
            $added++;
            $paragraph['entity']->{$field}['und'][$key]['value'] = $val;
          }
        }

      }
    }
    return $added > 0;
  }

  /**
   * For saving a value to "Interval" field type.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_interval_type(array $field_info, array $mapping, $value, $entity) {
    if (empty($value)) {
      return FALSE;
    }
    $s_values = explode($mapping['separator'], $value);
    $bundle = $mapping['paragraph_bundle'];
    $par_field = $mapping['paragraph_field'];
    $field = $mapping['field'];
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($s_values as $key => $field_val) {
      if (($added < $num_allowed || $skip_check) && !empty($field_val)) {
        if (strpos($field_val, 'y') !== FALSE) {
          $cleaned = str_replace('y', '', $field_val);
          $period = 'year';
        }
        elseif (strpos($field_val, 'd') !== FALSE) {
          $cleaned = str_replace('d', '', $field_val);
          $period = 'day';
        }
        elseif (strpos($field_val, 'h') !== FALSE) {
          $cleaned = str_replace('h', '', $field_val);
          $period = 'hour';
        }
        elseif (strpos($field_val, 'm') !== FALSE) {
          $cleaned = str_replace('m', '', $field_val);
          $period = 'minute';
        }
        elseif (strpos($field_val, 's') !== FALSE) {
          $cleaned = str_replace('s', '', $field_val);
          $period = 'second';
        }
        if (isset($period) && isset($cleaned)) {
          foreach ($entity->{$par_field}['und'] as $paragraph) {
            if ($paragraph['entity']->bundle === $bundle) {
              $added++;
              $final_val = ['interval' => $cleaned, 'period' => $period];
              $paragraph['entity']->{$field}['und'][$key] = $final_val;
            }
          }
        }
      }
    }
    return $added > 0;
  }

  /**
   * For saving a value to list field type.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_list_type(array $field_info, array $mapping, $value, $entity) {
    if (empty($value)) {
      return TRUE;
    }
    $s_values = explode($mapping['separator'], $value);
    $par_field = $mapping['paragraph_field'];
    $bundle = $mapping['paragraph_bundle'];
    $field = $mapping['field'];
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($entity->{$par_field}['und'] as $paragraph) {
      if ($paragraph['entity']->bundle === $bundle) {
        foreach ($s_values as $key => $field_val) {
          if (($added < $num_allowed || $skip_check)  && !empty($field_val)) {
            $added++;
            $paragraph['entity']->{$field}['und'][$key]['value'] = $field_val;
          }
        }
      }
    }
    return $added > 0;
  }

  /**
   * For saving a value to list field type.
   *
   * @param array $field_info
   *   The target field info.
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param object $entity
   *   The entity that is being edited.
   *
   * @return bool
   */
  function feeds_para_mapper_save_tax_terms_type(array $field_info, array $mapping, $value, $entity) {
    if (empty($value) || $field_info['type'] !== 'taxonomy_term_reference') {
      return FALSE;
    }
    $bundle = $mapping['paragraph_bundle'];
    $par_field = $mapping['paragraph_field'];
    $field = $mapping['field'];
    $s_values = explode($mapping['separator'], $value);
    $num_allowed = (int)$field_info['cardinality'];
    $skip_check = $num_allowed === -1;
    $added = 0;
    foreach ($entity->{$par_field}['und'] as $paragraph) {
      if ($paragraph['entity']->bundle === $bundle) {
        foreach ($s_values as $key => $field_val) {
          if (($added < $num_allowed || $skip_check) && !empty($field_val)) {
            $term = taxonomy_term_load($field_val);
            if ($mapping['default_voc'] == $term->vid) {
              $added++;
              $paragraph['entity']->{$field}['und'][$key]['tid'] = $field_val;
            }
          }
        }
      }
    }
    return $added > 0;
  }

  /**
   * Searches for terms and creates them.
   *
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param string $value
   *   The source field value.
   * @param array $field_info
   *   The target field info.
   *
   * @return array
   *   The terms array.
   */
  function feeds_para_mapper_check_terms(array $mapping, $value, array $field_info) {
    $founded_terms = [];
    $term_save_errors = [];
    // If we have a field of type taxonomy.
    if ($field_info['type'] == "taxonomy_term_reference") {
      // Convert source terms into array.
      $terms_to_map = explode($mapping['separator'], $value);
      $clean_terms = array_filter($terms_to_map, function ($val) {
          return !empty($val);
      });
      // Load terms.
      foreach ($clean_terms as $futTerm) {
        $term = taxonomy_get_term_by_name($futTerm);
        $term = reset($term);
        // If we did not found the term, and settings is auto create,
        // create the term.
        if (empty($term) && $mapping['auto_create']) {
          // Create the term.
          $termArr = [
            'vid' => $mapping['default_voc'],
            'name' => $futTerm,
          ];
          $to_create = (object) $termArr;
          $new_term = taxonomy_term_save($to_create);
          if (isset($new_term)) {
            $new_term = taxonomy_get_term_by_name($futTerm);
            $new_term = reset($new_term);
            $termArr['tid'] = $new_term->tid;
            array_push($founded_terms, $termArr);
          }
          else {
            // Save temp error to display later.
            array_push($term_save_errors, $termArr);
          }
        }
        elseif (!empty($term))  {
          // We found the term, save it temp.
          $termArr = [
            'vid' => $term->vid,
            'name' => $term->name,
            'tid' => $term->tid,
          ];
          array_push($founded_terms, $termArr);
        }
      }
    }
    $res = ['terms' => $founded_terms, 'errors' => $term_save_errors];
    return $res;
  }

  /**
   * Creates the settings form.
   *
   * @param array $mapping
   *   Contains the settings form fields values.
   * @param array $target
   *   The target field that is being mapped to.
   *
   * @return array
   *   The form markup array.
   */
  function feeds_para_mapper_create_field_settings_form(array $mapping, array $target) {
    if (isset($target['field']['tax_settings'])) {
      $form_settings['search_by'] = $target['field']['tax_settings']['search_by'];
      $form_settings['auto_create'] = $target['field']['tax_settings']['auto_create'];
      $form_settings['auto_create']['#default_value'] = $mapping['auto_create'];
      $form_settings['default_voc'] = $target['field']['tax_settings']['default_voc'];
      $form_settings['default_voc']['#default_value'] = $mapping['default_voc'];
    }
    $form_settings['separator']  = [
      '#type' => 'textfield',
      '#default_value' => $mapping['separator']? $mapping['separator']: ',',
      '#title' => t('Separator'),
      '#description' => t('A character used to separate multiple values.'),
    ];
    $form_settings['field'] = [
      '#type' => 'hidden',
      '#value' => $target['field']['machine_name']
    ];
    $form_settings['paragraph_bundle'] = [
      '#type' => 'hidden',
      '#value' => $target['field']['paragraph_bundle']
    ];
    $form_settings['paragraph_field'] = [
      '#type' => 'hidden',
      '#value' => $target['paragraph']['machine_name']
    ];
    return $form_settings;
  }

  /**
   * Creates the summary markup for the settings form.
   *
   * @param array $mapping
   *   Contains the settings form fields values.
   *
   * @return string
   *   The summary markup.
   */
  function feeds_para_mapper_sum_callback(array $mapping) {
    if (!isset($mapping['paragraph_field']) && empty($mapping['paragraph_bundle'])) {
      return t("Please configure");
    }
    $markup = t('Create @field paragraph', ['@field' => $mapping['paragraph_bundle']]);
    if (isset($mapping['auto_create'])) {
      $voc = taxonomy_vocabulary_load($mapping['default_voc']);
      $vars = [
        '@field' => $mapping['paragraph_bundle'],
        '@voc' => $voc->name
      ];
      $markup = t('Create @field paragraph & auto create new terms within @voc', $vars);
    }
    return $markup;
  }

  /**
   * Searches for fields that associated with the selected paragraph bundle.
   *
   * @param array $target
   *   The target field that is being mapped to.
   *
   * @return array
   *   The founded fields.
   */
  function feeds_para_get_para_bundle_fields(array $target) {
    $fields = field_info_field_map();
    $m_n = $target['field_info']['machine_name'];
    $c_t = $target['field_info']['bundle'];
    $f_in = field_info_instance('node', $m_n, $c_t);
    $a_b = array_values($f_in['settings']['allowed_bundles']);
    $para_assoc_fields = [];
    // Lookup all associated fields.
    foreach ($fields as $key => $field) {
      foreach ($field['bundles'] as $b_type => $as_bundles) {
        if ($b_type === 'paragraphs_item') {
          foreach ($as_bundles as $p_b) {
            foreach ($a_b as $a_b_i) {
              if ($a_b_i === $p_b) {
                $in = field_info_instance('paragraphs_item', $key, $p_b);
                $field['machine_name'] = $key;
                $field['label'] = $in['label'];
                $field['paragraph_bundle'] = $in['bundle'];
                array_push($para_assoc_fields, $field);
              }
            }
          }
        }
      }
    }
    foreach ($para_assoc_fields as $key => $para) {
      if ($para['type'] == "taxonomy_term_reference") {
        $para['tax_settings'] = feeds_para_mapper_init_tax_field_settings();
        $para_assoc_fields[$key] = $para;
      }
    }
    return $para_assoc_fields;
  }

  /**
   * Generates the taxonomy settings form.
   *
   * @return array
   *   The form markup.
   */
  function feeds_para_mapper_init_tax_field_settings() {
    $vocabulary = taxonomy_get_vocabularies();
    $checklist_vocab_array = array();
    foreach ($vocabulary as $item) {
      $key = $item->vid;
      $value = $item->name;
      $checklist_vocab_array[$key] = $value;
    }
    $tax_settings = [
      'search_by' => [
        '#type' => 'select',
        '#options' => [
          'term_name' => t('Term name'),
          'tid' => t('Term ID'),
          'guid' => t('GUID'),
        ],
        "#default_value" => 'Term name',
        '#title' => t('Search taxonomy terms by:'),
        '#description' => t("note: no need to use tamper for exploding terms, i already do this"),
      ],
      'default_voc' => [
        '#type' => 'select',
        '#options' => $checklist_vocab_array,
        "#default_value" => 0,
        '#title' => t('Default vocabulary'),
        '#description' => t("Default vocabulary for new terms."),
      ],
      'auto_create' => [
        '#type' => 'checkbox',
        "#default_value" => 0,
        '#title' => t('Auto create'),
        '#description' => t("Create the term if it doesn't exist."),
      ],
    ];
    return $tax_settings;
  }

  /**
   * Initiates an empty paragraph entity.
   *
   * @param object $entity
   *   The entity that is being edited.
   * @param array $mapping
   *   Contains the settings form fields values.
   *
   * @return \ParagraphsItemEntity
   *   The newly created paragraph item.
   */
  function feeds_para_mapper_get_init_para($entity, array $mapping) {
    $paragraph = NULL;
    $field_name = $mapping['paragraph_field'];
    // Find out if we have previously attached paragraphs.
    $has_paragraphs = isset($entity->{$field_name});
    if ($has_paragraphs) {
      //search for the target bundle:
      $bundle = $mapping['paragraph_bundle'];
      $found = array_filter($entity->{$field_name}['und'], function ($item) use ($bundle) {
        return $item['entity']->bundle === $bundle;
      });
      if (count($found)) {
        $paragraph = $found[0];
      }
      else {
        // Create new paragraph if not found
        $par_info = field_info_field($field_name);
        $allowed = (int)$par_info['cardinality'];
        $added = count($entity->{$field_name}['und']);
        if ($added < $allowed || $allowed === -1) {
          $paragraph = feeds_para_mapper_create_paragraph($bundle, $field_name, $entity);
        }
      }
    }
    else {
      $bundle = $mapping['paragraph_bundle'];
      $paragraph = feeds_para_mapper_create_paragraph($bundle, $field_name, $entity);
    }
    return $paragraph;
  }

  /**
   * Creates a new paragraph.
   *
   * @param string $paragraph_bundle
   * @param string $field_name
   * @param object $entity
   * 
   * @return \ParagraphsItemEntity
   */
  function feeds_para_mapper_create_paragraph($paragraph_bundle, $field_name, $entity) {
    $item = entity_create('paragraphs_item', [
      'bundle' => $paragraph_bundle,
      'field_name' => $field_name,
    ]);
    if ($item instanceof ParagraphsItemEntity) {
      try {
        $item->setHostEntity('node', $entity);
      } catch (Exception $exception) {

      }
    }
    return $item;
  }

  /**
   * Gets a file from URL or local path.
   *
   * @param string $url
   *   The url of the file.
   *
   * @return mixed
   *   object of the file if founded or uploaded, FALSE if failed.
   */
  function feeds_para_mapper_get_file($url) {
    $valid = filter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_PATH_REQUIRED);
    $is_image = function ($url) {
      $i_ext = ['jpg', 'jpeg', 'tiff', 'png', 'icon', 'ico'];
      $ext = end(explode('.', $url));
      foreach ($i_ext as $v_ext) {
        if ($ext === $v_ext) {
          return TRUE;
        }
      }
      return FALSE;
    };
    if ($valid) {
      // Download remote file.
      $file = system_retrieve_file($url, 'public://test.jpg', TRUE, FILE_EXISTS_REPLACE);
      if ($file) {
        if (!$is_image($url)) {
          $file->display = 1;
        }
        return $file;
      }
      else {
        $error = t("Error retrieving file %url", ['%url' => $url]);
        drupal_set_message($error, 'error');
        return FALSE;
      }
    }
    else {
      // If file is saved locally and exists in db:
      $files = file_load_multiple([], ['uri' => $url]);
      if ($files && count($files) > 0) {
        return array_values($files)[0];
      }
      else {
        // Doesn't exist on db, check if exist locally, load and save it:
        if (file_exists($url)) {
          $content = file_get_contents($url);
          if (strlen($content) > 0) {
            $file = file_save_data($content, NULL, FILE_EXISTS_REPLACE);
            if ($file && is_object($file)) {
              $name = explode('//', $url);
              $file->filemime = file_get_mimetype($url);
              $file->filename = $name[1];
              $file->uri = $url;
              $file->status = FILE_STATUS_PERMANENT;
              if (!$is_image($url)) {
                $file->display = 1;
              }
              $file = file_save($file);
              return $file;
            }
            else {
              $error = t("File %url couldn't be saved", ['%url' => $url]);
              drupal_set_message($error, 'error');
              return FALSE;
            }
          }
          else {
            $error = t("File %url is not valid", ['%url' => $url]);
            drupal_set_message($error, 'error');
            return FALSE;
          }
        }
        else {
          $error = t("File %url doesn't exist", ['%url' => $url]);
          drupal_set_message($error, 'error');
          return FALSE;
        }
      }
    }
  }

